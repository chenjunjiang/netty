# netty私有协议开发
该协议用于内部各模块之间的通信，它基于TCP/IP协议栈，是一个类HTTP协议的应用层协议栈，相比
传统的标准协议栈，它更加轻巧、灵活和实用。

该协议栈承载了业务内部各模块之间的消息交互和服务调用，主要功能如下：
1、基于Netty的NIO通信框架，提供高性能的异步通信能力；
2、提供消息的编解码框架，可以实现POJO的序列化和反序列化；
3、提供基于IP地址的白名单接入认证机制；
4、链路的有效性校验机制；
5、链路的断连重连机制；

通讯步骤如下：
1、协议栈客户端发送握手消息，携带节点ID等有效身份认证信息；
2、协议栈服务端对握手请求消息进行合法性校验，包括节点ID有效性校验、节点重复登录校验和IP地址
合法性校验，校验通过之后，返回登录成功的握手应答消息；
3、链路建立成功之后，客户端发送业务消息；
4、链路建立成功之后，服务端发送心跳信息；
5、链路建立成功之后，客户端发送心跳信息；
6、链路建立成功之后，服务端发送业务消息；
7、服务端退出时，服务端关闭连接，客户端感知对方关闭连接之后，被动关闭客户端连接。
需要指出的是，Netty协议通信双方链路建立成功之后，双方可以进行全双工通信，无论客户端还是服务端
，都可以主动发送请求消息给对方，通信方式可以是TWO WAY或者ONE WAY。双方之前的心跳采用Ping-Pong
机制，当链路处于空闲状态时，客户端主动发送Ping消息给服务端，服务端接收到Ping消息之后发送应答
消息Pong给客户端，如果客户端连续发送N条Ping消息都没有收到服务端返回的Pong消息，说明链路已经
挂死或者对方处于异常状态，客户端主动关闭连接，间隔周期T后发起重连操作，知道重连成功。

该协议栈消息定义包含两部分：
1、消息头
2、消息体

Netty消息定义表(NettyMessage)
名称	    类型	    长度	       描述
header	Header	变长	       消息头定义
body	Object	变长	       "对于请求消息，它是方法的参数；对于响应消息，它是返回值"

Netty消息头定义(Header)
名称	           类型	            长度	       描述
crcCode	       整型int	        32	       Netty消息的校验码，它由三部分组成：
                                           (1) 0xABEF：固定值，表明该消息是Netty协议消息，2个字节；
                                           (2) 主版本号：1~255，1个字节
                                           (3) 次版本号：1~255，1个字节
                                           crcCode = 0xABEF+主版本号+次版本号
length	      整型int	        32	       消息长度，整个消息，包括消息头和消息体
sessionID     长整型long         64         集群节点内全局唯一，由会话ID生成器生成
type          Byte              8          0：业务请求消息；1：业务响应消息；2：业务ONE WAY消息(既是请求又是响应消息)；
                                           3：握手请求消息；4：握手应答消息；5：心跳请求消息；6：心跳应答消息
priority      Byte              8          消息优先级：0~255
attachment    Map<String,Object>  变长      可选字段，用于扩展消息头

该协议支持的字段类型
字段类型	备注说明
boolean	包括它的包装类型
byte	包括它的包装类型
int	    int32
char	包括它的包装类型
short	包括它的包装类型
long	包括它的包装类型
float	包括它的包装类型
double	包括它的包装类型
string	对应String
list	支持各种List的实现
array	支持各种数组的实现
map	    支持Map的嵌套和泛型
set	    支持Set的嵌套和泛型

链路的建立
协议栈支持服务端和客户端，对于使用协议栈的应用程序而言，不需要刻意区分到底是客户端还是服务端，在分布式组网环境中，一个节点
肯能既是服务端也是客户端，这个依据具体的用户场景而定。
协议栈对客户端的说明如下：
如果A节点需要调用B节点的服务，但是A和B之间没有建立物理链路，则由调用方主动发起连接，此时，调用方为客户端，被调用方为服务端。
考虑安全，链路建立需要通过基于IP地址或者号段的黑白名单安全认证机制，作为样例，本协议基于IP地址的安全认证，如果有多个IP，
通过逗号进行分割。在实际商用项目中，安全认证机制更加严格，例如通过密钥对用户名和密码进行安全认证。
客户端与服务端链路建立成功之后，由客户端发送握手请求消息， 握手请求消息的定义如下：
1、消息头的type字段值为3；
2、可选附件个数为0；
3、消息体为空；
4、握手消息的长度为22个字节。
服务端接收到客户端的握手请求之后，如果IP校验通过，返回握手成功应答消息给客户端，应用层链路建立成功。握手应答消息定义如下：
1、消息头的type字段值为4；
2、可选附件个数为0；
3、消息体为byte类型的结果，"0"表示认证成功；"1"表示认证失败。
链路建立成功之后，客户端和服务端就可以互相发送业务消息了。

链路关闭
由于采用长连接通信，在正常的业务运行期间，双方通过心跳和业务消息维持链路，任何一方都不需要主动关闭连接。
但是，在以下情况下，客户端和服务端需要关闭连接：
1、当对方宕机或者重启时，会主动关闭链路，另一方读取到操作系统的通知信号，得知对方REST链路，需要关闭连接，释放
自身的句柄等资源。由于采用TCP全双工通信，通信双方都需要关闭连接，释放资源；
2、消息读写过程中，发生了IO异常，需要主动关闭连接；
3、心跳消息读写过程中发生了IO异常，需要主动关闭连接；
4、心跳超时，需要主动关闭连接；
5、发生编码异常等不可恢复错误时，需要主动关闭连接。

可靠性设计
    协议栈可能会运行在非常恶劣的网络环境中，网络超时、闪断、对方进程僵死或者处理缓慢等情况都有可能发生。为了保证这些
极端异常场景下协议栈仍能够正常工作或者自动恢复，需要对它的可靠性进行统一规划和设计。
1、心跳机制
    在凌晨等业务低谷时期，如果发生网络闪断、连接被Hang住等网络问题时，由于没有业务消息，应用进程很难发现。到了白天业务高峰期
时，会发生大量的网络通信失败，严重的会导致一段时间内进程无法处理业务消息。为了解决这个问题，在网络空闲时采用心跳机制来检测
链路的互通性，一旦发现网络故障，立即关闭链路，主动重连。具体设计思路如下：
(1)当网络处于空闲状态持续时间达到T（连续周期T没有读写消息）时，客户端主动发送Ping心跳消息给服务端。
(2)如果下一个周期T到来时客户端没有收到对方发送的Pong心跳应答消息或者读取到服务端发送的其它业务消息，则心跳失败计数器加1。
(3)每当客户端接收到服务的业务消息或Pong应答消息时，将心跳失败计数器清零；连续N次没有接收到服务端的Pong消息或业务消息，则
关闭链路，间隔INTERVAL时间后发起重连操作。
(4)服务端网络空闲状态持续时间达到T后，服务端将心跳失败计数器加1；只要接收到客户端发送的Ping消息或者其它业务消息，计数器清零。
(5)服务端连续N次没有接收到客户端的Ping消息或其它业务消息，则关闭链路，释放资源，等待客户端重连。
    通过Ping-Pong双向心跳机制，可以保证无论通信哪一方出现了网络故障，都能被及时地检测出来。为了防止由于对方短时间内繁忙没有及时
返回应答消息造成的误判，只有连续N次心跳检测都失败才认定链路已经损害，需要关闭链路并重建链路。
当读或写心跳消息发送IO异常的时候，说明链路已经中断，此时需要立即关闭链路，如果是客户端，需要重新发起连接。如果是服务端，
需要清空缓存的半包信息，等待客户端重连。
2、重连机制
    如果链路中断，等待INTERVAL时间后，由客户端发起重连操作，如果重连失败，间隔周期INTERVAL后再次发起重连，直到重连成功。
为了保证服务端能够有充足的时间释放句柄资源，在首次断连时客户端需要等待INTERVAL时间之后再次重连，而不是失败后就立即重连。
为了保证句柄资源能够及时释放， 无论什么场景下的重连失败，客户端都必须保证自身的资源被及时释放，包括但不限于SocketChannel
、Socket等。重连失败后，需要打印异常堆栈信息，方面后续的问题定位。
3、重复登录保护
    当客户端握手成功之后，在链路处于正常状态下，不允许客户端重复登录，以防止客户端在异常状态下反复重连导致句柄资源被耗尽。
服务端接收到客户端的握手请求消息之后，首先对IP地址进行合法性校验，如果校验成功，在缓存的地址表中查看客户端是否已经登录，
如果已经登录，则拒绝重复登录，返回错误码-1，同时关闭TCP链路，并在服务端的日志中打印握手失败的原因。
客户端收到握手失败的应答消息之后，关闭客户端的TCP连接，等待INTERVAL时间之后，再次发起TCP连接，直到认证成功。
为了防止由服务端和客户端对链路状态理解不一致而导致的客户端无法握手成功的问题，当服务端连续N次心跳超时之后需要主动关闭链路，
清空该客户端的地址缓存信息，以保证后续该客户端可以重连成功，防止被重复登录保护机制拒绝掉。
4、消息缓存重发
   无论客户端还是服务端，当发生链路中断之后，在链路恢复之前，缓存在消息队列中待发送的消息不能丢失，等链路恢复之后，重新
发送这些消息，保证链路中断期间的消息不丢失。考虑到内存溢出的风险，建议消息缓存队列设置上限，当达到上限之后，应该拒绝继续
向该队列添加新的消息。

安全性设计
    为了保证整个集群环境的安全，内部长连接采用基于IP地址的安全认证机制，服务端对握手请求消息的IP地址进行合法性校验：如果
在白名单之内，则校验通过；否则，拒绝对方连接。如果协议栈放到公网中使用，需要采用更加严格的安全认证机制，例如基于密钥和AES
加密的用户名+密码认证机制，也可以采用SSL/TSL安全传输。

可扩展性设计
    协议需要具备一定的扩展能力，业务可以在消息头中自定义业务域字段，例如消息流水号、业务自定义消息头等。通过消息头中的可选
附件attachment字段，业务可以方便地进行自定义扩展。协议栈架构需要具备一定的扩展能力，例如统一的消息拦截、接口日志、安全、加解密
等可以被方便地添加和删除，不需要修改之前的逻辑代码。

异常场景：服务端宕机重启
假设服务端宕机一段时间重启 ，检验如下功能是否正常：
1、客户端是否能够正常发起重连；
2、重连成功之后，不再重连；
3、断连期间，心跳定时器停止工作，不再发送心跳请求消息；
4、服务端重启之后，允许客户端重新登录；
5、服务端重启之后，客户端能够重连和握手成功；
6、重连成功之后，双方的心跳能够正常互发；
7、性能指标：重连期间，客户端资源得到了正常回收，不会导致句柄等资源泄露。

异常场景：客户端宕机重启
客户端宕机重启之后，服务端需要能够清除缓存信息，允许客户端重新登录。

总结
尽管该协议栈已经考虑了很多可靠性方面的功能， 但是对于实际商用协议栈而言，仍然是不足的。例如当链路断连的时候，已经放入发送
队列中的消息不能丢失，更加通用的做法是提供通知机制，将发送失败的消息通知给业务侧，由业务做决定：是丢弃还是缓存重发。



